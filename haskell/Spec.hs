head
tail
init
last
null
length
(!!)

foldr
foldl
foldr1
foldl1
map
reverse
(++)
(&&)
(||)
concat
concatMap
filter

max
min
maximum
minimum

repeat
replicate
cycle

-- tuples
fst
snd
curry
uncurry

drop
take
dropWhile
takeWhile
elem

zip
unzip
and
or
all
any
sum
product

-- math
even
odd
gcd
lcm

qsort
msort
isort

isPrime
primes
factors

subsets
permutations
choices

add
mul
sub
divMod
div
mod

isPrefix
contains

-- monads
sequence
mapM
sequence_
mapM_


-- flow
id
const
(.)
flip
($)


unfold
iterate

Maybe
fmap
(>>=)
(>>)

-- church numerals

Tree a = Leaf a | Node (Tree a) a (Tree a)
Tree b = Node b [Tree b]

occursSorted
occursUnsorted
flatten

-- graphs?
-- how can I use graph data structure?
-- graph searching algorithms





